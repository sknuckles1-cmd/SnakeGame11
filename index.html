<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Auto-Playing Snake Game</title>
    <style>
        body {
            display: flex;
            flex-direction: column; /* Stack elements vertically */
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            background-color: #f0f0f0;
            font-family: Arial, sans-serif;
        }
        h1 {
            margin-bottom: 10px;
            color: #333;
        }
        #scoreBoard {
            margin-bottom: 20px; /* Space between score and canvas */
            font-size: 1.5em;
            color: #555;
        }
        canvas {
            border: 5px solid #333;
            background-color: #fff;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }
        #gameOverMessage {
            position: absolute; /* Position over the canvas */
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: red;
            font-size: 2em;
            font-weight: bold;
            background-color: rgba(255, 255, 255, 0.8); /* Semi-transparent white background */
            padding: 15px;
            border-radius: 10px;
            display: none; /* Initially hidden */
            text-align: center; /* Center text if it wraps */
            z-index: 10; /* Ensure it's above the canvas */
        }
    </style>
</head>
<body>

    <h1>Auto-Playing Snake Game</h1>
    <div id="scoreBoard">Score: 0</div>
    <canvas id="gameCanvas" width="400" height="400"></canvas>
    <div id="gameOverMessage">
        Game Over!<br>
        <small>Refresh to Play Again</small>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreBoard = document.getElementById('scoreBoard');
        const gameOverMessage = document.getElementById('gameOverMessage');

        // Game constants
        const grid = 20; // Size of each square in the grid
        const canvasSize = canvas.width; // Assuming square canvas
        const tileCount = canvasSize / grid; // Number of tiles horizontally/vertically

        // Game state variables
        let snake = []; // Initialized in startGame
        let food = {};  // Initialized in startGame
        let dx = 0;     // Horizontal velocity (grid units per frame)
        let dy = 0;     // Vertical velocity (grid units per frame)
        let score = 0;
        let gameRunning = false;
        let gameInterval;

        // --- AI Helper Function: Check for Collision ---
        function isCollision(x, y, snakeArray) {
            // Check wall collision
            if (x < 0 || x >= tileCount || y < 0 || y >= tileCount) {
                return true;
            }
            // Check self collision
            for (let i = 0; i < snakeArray.length; i++) {
                if (x === snakeArray[i].x && y === snakeArray[i].y) {
                    return true;
                }
            }
            return false;
        }

        // --- AI Decision Making Function ---
        function decideNextMove() {
            const head = snake[0];
            const currentDx = dx; // Store current direction to avoid reversal
            const currentDy = dy;

            // 1. Calculate differences to food
            const diffX = food.x - head.x;
            const diffY = food.y - head.y;

            // 2. Define potential moves (preferred and alternative)
            let preferredMoves = [];
            let alternativeMoves = [];

            // Determine preferred axis based on larger distance
            if (Math.abs(diffX) > Math.abs(diffY)) {
                // Prefer horizontal
                if (diffX > 0) preferredMoves.push({ dx: 1, dy: 0 }); // Right
                else if (diffX < 0) preferredMoves.push({ dx: -1, dy: 0 }); // Left

                // Alternative is vertical
                if (diffY > 0) alternativeMoves.push({ dx: 0, dy: 1 }); // Down
                else if (diffY < 0) alternativeMoves.push({ dx: 0, dy: -1 }); // Up
                else { // If dy is 0, add both vertical as alternatives
                     alternativeMoves.push({ dx: 0, dy: -1 }); // Up
                     alternativeMoves.push({ dx: 0, dy: 1 });  // Down
                }

            } else {
                 // Prefer vertical
                if (diffY > 0) preferredMoves.push({ dx: 0, dy: 1 }); // Down
                else if (diffY < 0) preferredMoves.push({ dx: 0, dy: -1 }); // Up

                // Alternative is horizontal
                if (diffX > 0) alternativeMoves.push({ dx: 1, dy: 0 }); // Right
                else if (diffX < 0) alternativeMoves.push({ dx: -1, dy: 0 }); // Left
                 else { // If dx is 0, add both horizontal as alternatives
                     alternativeMoves.push({ dx: -1, dy: 0 }); // Left
                     alternativeMoves.push({ dx: 1, dy: 0 });  // Right
                 }
            }
             // Handle case where head is exactly on food (should be rare, but good to handle)
            if (diffX === 0 && diffY === 0) {
                 // Keep current direction if possible and safe
                 preferredMoves.push({dx: currentDx, dy: currentDy});
            }


            // 3. Test preferred moves first
            for (const move of preferredMoves) {
                const nextX = head.x + move.dx;
                const nextY = head.y + move.dy;
                // Avoid immediate reversal if snake is longer than 1 segment
                const isReversing = snake.length > 1 && move.dx === -currentDx && move.dy === -currentDy;

                if (!isCollision(nextX, nextY, snake) && !isReversing) {
                    dx = move.dx;
                    dy = move.dy;
                    return; // Found a safe preferred move
                }
            }

             // 4. Test alternative moves if no preferred move worked
            for (const move of alternativeMoves) {
                const nextX = head.x + move.dx;
                const nextY = head.y + move.dy;
                const isReversing = snake.length > 1 && move.dx === -currentDx && move.dy === -currentDy;

                if (!isCollision(nextX, nextY, snake) && !isReversing) {
                    dx = move.dx;
                    dy = move.dy;
                    return; // Found a safe alternative move
                }
            }

            // 5. Fallback: If all direct routes to food are blocked, try *any* safe move
            // Try continuing straight first if safe (if not reversing)
            const straightX = head.x + currentDx;
            const straightY = head.y + currentDy;
            if( !(currentDx === 0 && currentDy === 0) && !isCollision(straightX, straightY, snake)){
                 dx = currentDx;
                 dy = currentDy;
                 // console.log("Fallback: Continuing straight"); // Debugging
                 return;
            }

            // If straight is blocked, check all four directions
             const possibleMoves = [
                 { dx: 0, dy: -1 }, // Up
                 { dx: 1, dy: 0 },  // Right
                 { dx: 0, dy: 1 },  // Down
                 { dx: -1, dy: 0 } // Left
             ];

             for (const move of possibleMoves) {
                 const nextX = head.x + move.dx;
                 const nextY = head.y + move.dy;
                 // Prevent immediate reversal only if snake is longer than 1
                 const isReversing = snake.length > 1 && move.dx === -currentDx && move.dy === -currentDy;

                 if (!isCollision(nextX, nextY, snake) && !isReversing) {
                    // console.log("Fallback: Trying general safe move", move); // Debugging
                     dx = move.dx;
                     dy = move.dy;
                     return; // Found *any* safe move
                 }
             }

             // If we reach here, there are NO safe moves. The game will end on the next step.
             // We can just let the current dx/dy persist, which will cause a collision.
             // console.log("No safe moves found!"); // Debugging
        }


        // --- Game Functions ---

        function main() {
            if (!gameRunning) return; // Stop the loop if game over

            const speed = 100 - Math.min(score * 1.5, 80); // Slightly faster auto-play speed baseline
            gameInterval = setTimeout(() => {

                // *** AI makes decision HERE ***
                decideNextMove();

                clearCanvas();
                moveSnake(); // Move based on dx/dy set by AI
                drawFood();
                drawSnake();

                if (isGameOver()) {
                    endGame();
                    return;
                }
                main(); // Call the next game loop
            }, speed);
        }

        function startGame() {
            // Reset state
            snake = [{ x: 10, y: 10 }]; // Start in the middle
            generateFood(); // Place initial food randomly
            score = 0;
            scoreBoard.textContent = `Score: ${score}`;
            gameOverMessage.style.display = 'none';
            gameRunning = true;

            // *** Set Initial Direction for Auto-Play ***
            dx = 1; // Start moving right
            dy = 0;

            // Clear any existing interval if restarting
            if (gameInterval) {
                clearTimeout(gameInterval);
            }

            // *** Start the game loop immediately ***
            main();
        }

        function endGame() {
            gameRunning = false;
            clearTimeout(gameInterval); // Stop the loop
            gameOverMessage.style.display = 'block'; // Show game over message
        }

        function clearCanvas() {
            ctx.fillStyle = '#fff';
            ctx.fillRect(0, 0, canvasSize, canvasSize);
        }

        function drawSnakePart(part) {
            ctx.fillStyle = 'blue'; // Changed color for AI snake
            ctx.strokeStyle = 'darkblue';
            ctx.lineWidth = 1;
            ctx.fillRect(part.x * grid, part.y * grid, grid, grid);
            ctx.strokeRect(part.x * grid, part.y * grid, grid, grid);
        }

        function drawSnake() {
            snake.forEach(drawSnakePart);
        }

        function moveSnake() {
            // Calculate new head position based on dx, dy (set by AI)
            const head = { x: snake[0].x + dx, y: snake[0].y + dy };
            snake.unshift(head); // Add new head

            // Check if snake ate food
            if (head.x === food.x && head.y === food.y) {
                score++;
                scoreBoard.textContent = `Score: ${score}`;
                generateFood(); // Generate new food
            } else {
                snake.pop(); // Remove tail segment
            }
        }

        function drawFood() {
            ctx.fillStyle = 'red';
            ctx.strokeStyle = 'darkred';
            ctx.lineWidth = 1;
            ctx.fillRect(food.x * grid, food.y * grid, grid, grid);
            ctx.strokeRect(food.x * grid, food.y * grid, grid, grid);
        }

        function generateFood() {
            let newFoodPosition;
            do {
                newFoodPosition = {
                    x: Math.floor(Math.random() * tileCount),
                    y: Math.floor(Math.random() * tileCount)
                };
            } while (isFoodOnSnake(newFoodPosition));
            food = newFoodPosition;
        }

        function isFoodOnSnake(position) {
            return snake.some(part => part.x === position.x && part.y === position.y);
        }

        // *** changeDirection function is REMOVED ***

        function isGameOver() {
             const head = snake[0];
             // Check wall collision
             if (head.x < 0 || head.x >= tileCount || head.y < 0 || head.y >= tileCount) {
                return true;
             }
             // Check self collision (check against the rest of the body)
             for (let i = 1; i < snake.length; i++) {
                 if (head.x === snake[i].x && head.y === snake[i].y) {
                    return true;
                 }
             }
             return false;
        }

        // --- Event Listeners ---
        // *** NO keydown listener needed ***

        // --- Initial Setup ---
        startGame(); // Start the game automatically on load

    </script>

</body>
</html>
